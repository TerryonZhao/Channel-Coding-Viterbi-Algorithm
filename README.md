# SSY125 Communication System Project

## Overview
This repository contains the implementation of a communication system with various encoding, modulation, and decoding schemes. The project was developed for the SSY125 course and focuses on evaluating different coding techniques and their performance in terms of Bit Error Rate (BER) versus Signal-to-Noise Ratio (Eb/N0).

## Project Structure
- **Root Directory**: Contains the main implementation files and the central simulation script (`main.m`).
- **Task1**: Implementation and analysis of upper bounds on BER, coding gain calculation.
- **Task2**: Comparison of different convolutional codes.
- **Task3**: Analysis of power efficiency for different schemes.
- **Task4**: Implementation of LDPC codes using MATLAB toolbox.
- **images**: Contains result plots from various simulations.

## Key Components
1. **Encoders**: Implementation of convolutional encoders with various rates and constraints.
2. **Modulators**: Includes QPSK modulation.
3. **Channel**: AWGN (Additive White Gaussian Noise) channel.
4. **Decoders**: Hard and soft Viterbi decoders.

## Usage Guide
1. For all tasks, you can directly run the main file in the corresponding directory (e.g., `task1_main.m`) to obtain the plots.
2. The files in the root directory serve as the foundation of this project. The `main.m` file in the root directory can be used to simulate all required scenarios.
3. When using the `main.m` file in the root directory, modify the parameters `idx_enc`, `idx_mod`, and `idx_rec` to simulate the desired system.
4. When using the `main.m` file in the root directory, if you want to use the soft decoder, you need to comment out the line:
   ```matlab
   trellis = build_trellis(idx_enc);
   ```
5. Note that the hard decoder may take some time to complete.

## Key Files
- `build_trellis.m`: Constructs the trellis diagram for the convolutional encoder
- `encoder.m`: Encodes the input bit sequence using convolutional coding
- `mapper.m`: Maps encoded bits into QPSK symbols
- `awgn.m`: Adds Gaussian noise to the modulated symbols
- `demapper.m`: Demodulates the received symbols back into bits
- `hard_decoder.m`: Implements the Viterbi algorithm with hard decision metrics
- `soft_new.m`: Implements soft decoding using Euclidean distance
- `traceback*.m`: Implements traceback algorithms for different encoders
- `main.m`: Main simulation script for various configurations

## Results
The project includes various result plots showing BER performance versus Eb/N0 for different coding schemes. These can be regenerated by running the respective task scripts.

### Key Result Visualizations
Below are some of the key results from our simulations:

![BER vs Eb/N0 with ε2 and QPSK](images/BER%20vs%20Eb:N0%20with%20ε2%20and%20QPSK.jpg)

![Performance Comparison between Hard and Soft Receivers](images/Performance%20Comparison%20between%20Hard%20and%20Soft%20Receivers%20.jpg)

![Performance Comparison between 3 Systems](images/Performance%20Comparison%20between%203%20Systems%20.jpg)

![Performance Comparison of Different Rate-1:2 Convolutional Encoders](images/Performance%20Comparison%20of%20Different%20Rate-1:2%20Convolutional%20Encoders.jpg)

---

# SSY125 通信系统项目

## 概述
本仓库包含了一个通信系统的实现，涵盖了各种编码、调制和解码方案。该项目是为SSY125课程开发的，重点关注不同编码技术及其在比特错误率(BER)与信噪比(Eb/N0)方面的性能评估。

## 项目结构
- **根目录**：包含主要实现文件和中央仿真脚本(`main.m`)。
- **Task1**：BER上界实现与分析，编码增益计算。
- **Task2**：不同卷积码的比较。
- **Task3**：不同方案的功率效率分析。
- **Task4**：使用MATLAB工具箱实现LDPC码。
- **images**：包含各种仿真结果图。

## 主要组件
1. **编码器**：实现了具有不同码率和约束的卷积编码器。
2. **调制器**：包括QPSK调制。
3. **信道**：AWGN(加性白高斯噪声)信道。
4. **解码器**：硬判决和软判决Viterbi解码器。

## 使用指南
1. 对于所有任务，您可以直接运行相应目录中的主文件(例如`task1_main.m`)来获取图表。
2. 根目录中的文件是本项目的基础。根目录中的`main.m`文件可用于模拟所有所需的场景。
3. 使用根目录中的`main.m`文件时，修改参数`idx_enc`、`idx_mod`和`idx_rec`来模拟所需的系统。
4. 使用根目录中的`main.m`文件时，如果要使用软解码器，需要注释掉以下行：
   ```matlab
   trellis = build_trellis(idx_enc);
   ```
5. 请注意，硬解码器可能需要一些时间来完成。

## 主要文件
- `build_trellis.m`：为卷积编码器构建格架图
- `encoder.m`：使用卷积编码对输入比特序列进行编码
- `mapper.m`：将编码比特映射成QPSK符号
- `awgn.m`：为调制符号添加高斯噪声
- `demapper.m`：将接收到的符号解调回比特
- `hard_decoder.m`：实现带硬判决度量的Viterbi算法
- `soft_new.m`：使用欧几里得距离实现软解码
- `traceback*.m`：为不同编码器实现回溯算法
- `main.m`：用于各种配置的主仿真脚本

## 结果
该项目包括各种结果图，显示了不同编码方案的BER性能与Eb/N0的关系。这些可以通过运行相应的任务脚本重新生成。

### 主要结果可视化
以下是我们仿真的一些关键结果：

![BER vs Eb/N0与ε2和QPSK](images/BER%20vs%20Eb:N0%20with%20ε2%20and%20QPSK.jpg)

![硬判决和软判决接收器性能比较](images/Performance%20Comparison%20between%20Hard%20and%20Soft%20Receivers%20.jpg)

![三种系统性能比较](images/Performance%20Comparison%20between%203%20Systems%20.jpg)

![不同速率1:2卷积编码器性能比较](images/Performance%20Comparison%20of%20Different%20Rate-1:2%20Convolutional%20Encoders.jpg)

# 必要文件说明

以下是不同文件的描述。

## 基本模块

以下文件是仿真所必需的，已创建或修改：

1. [`build_trellis.m`](#): 构建卷积编码器的格架图，这对Viterbi解码器至关重要。
2. [`encoder.m`](#): 使用卷积编码对输入比特序列进行编码。
3. [`mapper.m`](#): 将编码比特映射为QPSK符号进行传输。
4. [`awgn.m`](#): 根据指定的Eb/N0为调制符号添加高斯噪声。
5. [`demapper.m`](#): 将接收到的符号解调回比特。本实现中仅考虑QPSK解映射。
6. [`hard_decoder.m`](#): 实现带硬判决度量的Viterbi解码算法。
7. [`soft_new.m`](#): 通过比较欧几里得距离使用软解码。
8. [`traceback.m`](#): 根据不同的编码器实现回溯算法。
9. [`get_uncoded_BER.m`](#): 获取未编码情况下的BER向量。
10. [`main.m`](#): 运行各种Eb/N0值的仿真并绘制比特错误率(BER)与Eb/N0的关系图的主脚本。

## 任务1
1. [`trellis_ub.m`](#): 生成用于计算上界的格架结构。
2. [`calculate_bound.m`](#): 根据距离谱和Eb/N0值计算编码通信系统比特错误概率的上界。
3. [`coding_gain_cal.m`](#): 通过插值BER与Eb/N0曲线找到目标BER为10e-4所需的Eb/N0，计算QPSK中软、硬解码的编码增益。
4. [`min_EbN0.m`](#): 通过插值和识别与未编码传输的交叉点，计算可靠通信的最小Eb/N0。

## 任务2
1. [`trellis_ub.m`](#): 与任务1相同
2. [`calculate_bound.m`](#): 与任务1相同

## 任务3
1. [`cal_PowerEff.m`](#): 通过比较BER=10e-4时所需的Eb/N0反映功率效率。

