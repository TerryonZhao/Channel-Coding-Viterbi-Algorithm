# SSY125 Communication System Project

## Overview
This repository contains the implementation of a communication system with various encoding, modulation, and decoding schemes. The project was developed for the SSY125 course and focuses on evaluating different coding techniques and their performance in terms of Bit Error Rate (BER) versus Signal-to-Noise Ratio (Eb/N0).

## Project Structure
- **Root Directory**: Contains the main implementation files and the central simulation script (`main.m`).
- **Task1**: Implementation and analysis of upper bounds on BER, coding gain calculation.
- **Task2**: Comparison of different convolutional codes.
- **Task3**: Analysis of power efficiency for different schemes.
- **Task4**: Implementation of LDPC codes using MATLAB toolbox.
- **images**: Contains result plots from various simulations.

## Key Components
1. **Encoders**: Implementation of convolutional encoders with various rates and constraints.
2. **Modulators**: Includes QPSK modulation.
3. **Channel**: AWGN (Additive White Gaussian Noise) channel.
4. **Decoders**: Hard and soft Viterbi decoders.

## Usage Guide
1. For all tasks, you can directly run the main file in the corresponding directory (e.g., `task1_main.m`) to obtain the plots.
2. The files in the root directory serve as the foundation of this project. The `main.m` file in the root directory can be used to simulate all required scenarios.
3. When using the `main.m` file in the root directory, modify the parameters `idx_enc`, `idx_mod`, and `idx_rec` to simulate the desired system.
4. When using the `main.m` file in the root directory, if you want to use the soft decoder, you need to comment out the line:
   ```matlab
   trellis = build_trellis(idx_enc);
   ```
5. Note that the hard decoder may take some time to complete.

## Key Files
- `build_trellis.m`: Constructs the trellis diagram for the convolutional encoder
- `encoder.m`: Encodes the input bit sequence using convolutional coding
- `mapper.m`: Maps encoded bits into QPSK symbols
- `awgn.m`: Adds Gaussian noise to the modulated symbols
- `demapper.m`: Demodulates the received symbols back into bits
- `hard_decoder.m`: Implements the Viterbi algorithm with hard decision metrics
- `soft_new.m`: Implements soft decoding using Euclidean distance
- `traceback*.m`: Implements traceback algorithms for different encoders
- `main.m`: Main simulation script for various configurations

## Results
The project includes various result plots showing BER performance versus Eb/N0 for different coding schemes. These can be regenerated by running the respective task scripts.

### Key Result Visualizations
Below are some of the key results from our simulations:

![BER vs Eb/N0 with ε2 and QPSK](images/BER%20vs%20Eb:N0%20with%20ε2%20and%20QPSK.jpg)

This figure demonstrates the relationship between Bit Error Rate (BER) and Signal-to-Noise Ratio (Eb/N0) when using an ε2 convolutional encoder with QPSK modulation. The graph compares theoretical upper bounds with actual simulation results, validating that the system performance aligns with theoretical expectations. It can be observed that as Eb/N0 increases, BER decreases exponentially, indicating that coding techniques effectively enhance communication system reliability.

![Performance Comparison between Hard and Soft Receivers](images/Performance%20Comparison%20between%20Hard%20and%20Soft%20Receivers%20.jpg)

This graph compares the performance of hard-decision and soft-decision Viterbi decoders under identical channel conditions. The figure clearly illustrates that soft-decision receivers outperform hard-decision receivers across all signal-to-noise ratios, with particularly significant performance improvements in the medium SNR range (approximately 5-8dB). This is because soft-decision decoders utilize confidence information from the received signals rather than just binary decision results, thereby providing more reliable decoding performance in noisy environments.

![Performance Comparison between 3 Systems](images/Performance%20Comparison%20between%203%20Systems%20.jpg)

This figure presents a performance comparison of three different system configurations: uncoded systems, convolutional coded systems, and LDPC coded systems. The results clearly demonstrate the importance of coding techniques in improving system noise resistance. At the same BER level, coded systems require lower SNR compared to uncoded systems, exhibiting significant coding gain. LDPC coding, in particular, shows excellent performance in high SNR regions, approaching the Shannon limit and demonstrating the powerful potential of modern coding technology.

![Performance Comparison of Different Rate-1:2 Convolutional Encoders](images/Performance%20Comparison%20of%20Different%20Rate-1:2%20Convolutional%20Encoders.jpg)

This graph compares the performance of rate-1:2 convolutional encoders with different constraint lengths. It can be observed that encoders with longer constraint lengths provide better coding performance, as they offer stronger error correction capabilities. However, this performance improvement comes at the cost of increased decoding complexity. The figure also shows the correlation between theoretical bounds and actual simulation results, verifying the correctness of the system implementation and providing reference for encoder selection in different application scenarios.

---

# SSY125 通信系统项目

## 概述
本仓库包含了一个通信系统的实现，涵盖了各种编码、调制和解码方案。该项目是为SSY125课程开发的，重点关注不同编码技术及其在比特错误率(BER)与信噪比(Eb/N0)方面的性能评估。

## 项目结构
- **根目录**：包含主要实现文件和中央仿真脚本(`main.m`)。
- **Task1**：BER上界实现与分析，编码增益计算。
- **Task2**：不同卷积码的比较。
- **Task3**：不同方案的功率效率分析。
- **Task4**：使用MATLAB工具箱实现LDPC码。
- **images**：包含各种仿真结果图。

## 主要组件
1. **编码器**：实现了具有不同码率和约束的卷积编码器。
2. **调制器**：包括QPSK调制。
3. **信道**：AWGN(加性白高斯噪声)信道。
4. **解码器**：硬判决和软判决Viterbi解码器。

## 使用指南
1. 对于所有任务，您可以直接运行相应目录中的主文件(例如`task1_main.m`)来获取图表。
2. 根目录中的文件是本项目的基础。根目录中的`main.m`文件可用于模拟所有所需的场景。
3. 使用根目录中的`main.m`文件时，修改参数`idx_enc`、`idx_mod`和`idx_rec`来模拟所需的系统。
4. 使用根目录中的`main.m`文件时，如果要使用软解码器，需要注释掉以下行：
   ```matlab
   trellis = build_trellis(idx_enc);
   ```
5. 请注意，硬解码器可能需要一些时间来完成。

## 主要文件
- `build_trellis.m`：为卷积编码器构建格架图
- `encoder.m`：使用卷积编码对输入比特序列进行编码
- `mapper.m`：将编码比特映射成QPSK符号
- `awgn.m`：为调制符号添加高斯噪声
- `demapper.m`：将接收到的符号解调回比特
- `hard_decoder.m`：实现带硬判决度量的Viterbi解码算法
- `soft_new.m`：通过比较欧几里得距离使用软解码
- `traceback.m`：根据不同的编码器实现回溯算法
- `main.m`：用于各种配置的主仿真脚本

## 结果
该项目包括各种结果图，显示了不同编码方案的BER性能与Eb/N0的关系。这些可以通过运行相应的任务脚本重新生成。

### 主要结果可视化
以下是我们仿真的一些关键结果：

![BER vs Eb/N0与ε2和QPSK](images/BER%20vs%20Eb:N0%20with%20ε2%20and%20QPSK.jpg)

该图展示了使用ε2卷积编码器和QPSK调制方案时，比特错误率(BER)与信噪比(Eb/N0)的关系。图中包含了理论上界曲线和实际仿真结果的对比，验证了系统性能符合理论预期。可以观察到随着Eb/N0的增加，BER呈指数级下降，这表明编码技术有效提高了通信系统的可靠性。

![硬判决和软判决接收器性能比较](images/Performance%20Comparison%20between%20Hard%20and%20Soft%20Receivers%20.jpg)

该图比较了硬判决和软判决Viterbi解码器在相同信道条件下的性能表现。从图中可以清晰地看出，软判决接收器在各个信噪比下均优于硬判决接收器，尤其是在中等信噪比区域（约5-8dB）性能提升更为显著。这是因为软判决解码器利用了接收信号的置信度信息，而不仅仅是二进制判决结果，从而在噪声环境中提供了更可靠的解码性能。

![三种系统性能比较](images/Performance%20Comparison%20between%203%20Systems%20.jpg)

该图展示了三种不同系统配置的性能比较：未编码系统、卷积编码系统和LDPC编码系统。结果清晰地表明了编码技术对提高系统抗噪能力的重要性。在相同BER水平下，编码系统相比未编码系统需要更低的信噪比，表现出明显的编码增益。特别是LDPC编码在高信噪比区域表现出色，接近Shannon极限，展示了现代编码技术的强大潜力。

![不同速率1:2卷积编码器性能比较](images/Performance%20Comparison%20of%20Different%20Rate-1:2%20Convolutional%20Encoders.jpg)

该图比较了不同约束长度的率为1:2的卷积编码器性能。从图中可以观察到，约束长度越长，编码性能越好，这是因为更长的约束长度提供了更强的纠错能力。然而，这种性能提升是以增加解码复杂度为代价的。图中还显示了理论上界与实际仿真结果的吻合程度，验证了系统实现的正确性，并为不同应用场景下的编码器选择提供了参考依据。

# 必要文件说明

以下是不同文件的描述。

## 基本模块

以下文件是仿真所必需的，已创建或修改：

1. [`build_trellis.m`](#): 构建卷积编码器的格架图，这对Viterbi解码器至关重要。
2. [`encoder.m`](#): 使用卷积编码对输入比特序列进行编码。
3. [`mapper.m`](#): 将编码比特映射为QPSK符号进行传输。
4. [`awgn.m`](#): 根据指定的Eb/N0为调制符号添加高斯噪声。
5. [`demapper.m`](#): 将接收到的符号解调回比特。本实现中仅考虑QPSK解映射。
6. [`hard_decoder.m`](#): 实现带硬判决度量的Viterbi解码算法。
7. [`soft_new.m`](#): 通过比较欧几里得距离使用软解码。
8. [`traceback.m`](#): 根据不同的编码器实现回溯算法。
9. [`get_uncoded_BER.m`](#): 获取未编码情况下的BER向量。
10. [`main.m`](#): 运行各种Eb/N0值的仿真并绘制比特错误率(BER)与Eb/N0的关系图的主脚本。

## 任务1
1. [`trellis_ub.m`](#): 生成用于计算上界的格架结构。
2. [`calculate_bound.m`](#): 根据距离谱和Eb/N0值计算编码通信系统比特错误概率的上界。
3. [`coding_gain_cal.m`](#): 通过插值BER与Eb/N0曲线找到目标BER为10e-4所需的Eb/N0，计算QPSK中软、硬解码的编码增益。
4. [`min_EbN0.m`](#): 通过插值和识别与未编码传输的交叉点，计算可靠通信的最小Eb/N0。

## 任务2
1. [`trellis_ub.m`](#): 与任务1相同
2. [`calculate_bound.m`](#): 与任务1相同

## 任务3
1. [`cal_PowerEff.m`](#): 通过比较BER=10e-4时所需的Eb/N0反映功率效率。

